GTY Transceiver
###############

Introduction
===============

GTY transceivers are organized in quads. Each quad contains one ``GTYE4_COMMON`` and four ``GTYE4_CHANNEL``. The primitives are very minimally documented; for most parameters the only mention in the datasheet is "use the magic value from the wizard". This page aims to provide some more fundamental understanding of the actual attributes, sufficient to enable use of the raw primitives without the wizard.

GTYs can operate at a maximum data rate of 32.75 Gbps (package and speed grade dependent).

Information in this page is derived from careful reading of DS922, analysis of configurations generated by the Vivado 2019.2 transceivers wizard, and testing on live hardware. (The wizard on newer Vivado versions, at least on certain Linux platforms, appears to be buggy and generate some parts of the config for 10Gbase-R regardless of what the user has selected in the dialog)

The UltraScale+ GTYE4 has common heritage with the UltraScale GTY and much of the analysis in this page will likely translate to the GTY

Clocking
-----------

TX and RX of each channel can be clocked independently from one of three sources:

* QPLL0 (in COMMON block, shared by all CHANNELs in the quad)
* QPLL1 (in COMMON block, shared by all CHANNELs in the quad)
* CPLL (in CHANNEL block, dedicated to this CHANNEL)

Each PLL has a different operating frequency range, which must be carefully considered when planning complex setups with multiple lanes in a quad running at different data rates.

In the case of KU+, the native data rates for each PLL at the nominal Vcore are as follows. To run at lower rates than shown here, the QPLL output divider and/or channel sub-rate modes must be used.

* CPLL: 4.0 to:
	* -1 speed: 8.5 Gbps
	* -2 or -3 speed: 12.5 Gbps
* QPLL0: 19.6 to:
    * -1 speed: 25.785 Gbps
    * -2 speed: 28.21 Gbps
    * -3 speed: 32.75 Gbps
* QPLL1: 16.0 to:
    * -1 speed: 25.785 Gbps
    * -2 or -3 speed: 26.0 Gbps

Check table 64 of DS922 for full details on voltage ranges and data rates.

Note that the internal transceiver drive circuitry is DDR, i.e. for 20 Gbps data rate the PLL VCO should be running at 10 GHz.

Each quad has two reference clock I/Os. Unlike previous generations of transceiver the reference clock pairs are *not* strictly inputs, it is possible to use them as recovered clock outputs too. TODO: document how recovered clock output works once we have a board that pins out some extra refclk signals we can poke at with a scope

``GTYE4_COMMON``
================

The ``GTYE4_COMMON`` contains two PLLs (QPLL0 and QPLL1) plus a completely undocumented hard MicroBlaze processor whose functionality is currently unknown.

Attributes
-----------

* | ``BIAS_CFG0``
  | Related to some kind of internal bias voltage. Always ``16'b0000000000000000``

* | ``BIAS_CFG1``
  | Related to some kind of internal bias voltage. Always ``16'b0000000000000000``

* | ``BIAS_CFG2``
  | Related to some kind of internal bias voltage. Always ``16'b0000010100100100``

* | ``BIAS_CFG3``
  | Related to some kind of internal bias voltage. Always ``16'b0000000001000001``

* | ``BIAS_CFG4``
  | Related to some kind of internal bias voltage. Always ``16'b0000000000010000``

* | ``BIAS_CFG_RSVD``
  | Related to some kind of internal bias voltage. Always ``16'b0000000000000000``

* | ``COMMON_CFG0``
  | Always ``16'b0000000000000000``

* | ``COMMON_CFG1``
  | Always ``16'b0000000000000000``

* | ``POR_CFG``
  | Related to power-on reset. Always ``16'b0000000000000000``

* | ``PPF0_CFG``
  | Something to do with QPLL0. Not yet fully understood. So far:

  * Bits 15:13: always 0
  * Bit 12: 1 if using fractional-N, 0 if not
  * Bit 11: 0 if using fractional-N, 1 if not
  * Bit 10: both 0 and 1 seen, but no clear pattern yet
  * Bits 9:0: always 0

* | ``PPF1_CFG``
  | Seems to be same mapping as PPF0_CFG but for QPLL1

* | ``QPLL0CLKOUT_RATE``
  | QPLL0 output divide-by-two control.

  * ``HALF``: Enable the output divider (output clock is half the VCO rate)
  * ``FULL``: Bypass the divider (output clock is equal to the VCO rate)

* | ``QPLL0_CFG0``
  | Always ``16'b0011001100011100``

* | ``QPLL0_CFG1``
  | Always ``16'b1101000000111000``

* | ``QPLL0_CFG1_G3``
  | Always ``16'b1101000000111000``

* | ``QPLL0_CFG2``
  | Something to do with QPLL0. Not yet fully understood. So far:

  * Bits 15:12: always 0
  * Bits 11:6: always 1
  * Bits 5:2: always 0
  * Bits 1:0: both 1 if using fractional-N, 0 if not

* | ``QPLL0_CFG2_G3``
  | Always same as ``QPLL0_CFG2`` in testing to date

* | ``QPLL0_CFG3``
  | Always ``16'b0000000100100000``

* | ``QPLL0_CFG4``
  | Something to do with QPLL0. Not yet fully understood. So far:

  * Bits 15:8: always 0
  * Bit 7: 1 if using fractional-N, 0 if not
  * Bits 6:3: always 0
  * Bit 2: 1 if using fractional-N, 0 if not
  * Bit 1: 0 if using fractional-N, 1 if not
  * Bit 0: both 0 and 1 seen, but no clear pattern yet

* | ``QPLL0_CP``
  | Related to QPLL0 charge pump. Always ``10'b0011111111``

* | ``QPLL0_CP_G3``
  | Related to QPLL0 charge pump. Always ``10'b0000001111``

* | ``QPLL0_FBDIV``
  | QPLL0 feedback divider N. Set to an integer between 16 and 160 to control the PLL multiplier between VCO and PFD.

* | ``QPLL0_FBDIV_G3``
  | Related to QPLL0 feedback divider but not yet understood. Values seen so far 160 and 128. Possible values in DRP range 16 to 160. TODO reverse this more

* | ``QPLL0_INIT_CFG0``
  | Always ``16'b0000001010110010``

* | ``QPLL0_INIT_CFG1``
  | Always ``8'b00000000``

* | ``QPLL0_LOCK_CFG``
  | Always ``16'b0010010111101000``

* | ``QPLL0_LOCK_CFG_G3``
  | Always ``16'b0010010111101000``

* | ``QPLL0_LPF``
  | Controls something in the QPLL0 loop filter

  * Bit 9: always 1
  * Bits 8:6: always 0
  * Bit 5: 0 if using fractional-N, 1 if not
  * Bits 4:0: always 1

* | ``QPLL0_LPF_G3``
  | Always ``10'b0111010101``

* | ``QPLL0_PCI_EN``
  | Always ``1'b0`` in all configurations tested to date, but we have not tested anything using the PCIe IP.

* | ``QPLL0_RATE_SW_USE_DRP``
  | Always ``1'b1``

* | ``QPLL0_REFCLK_DIV``
  | QPLL0 reference clock divider. Set to an integer between 1 and 4 to control the input divider between refclk input and PFD.

  | NOTE: according to UG578 table B-1, this attribute can also take the values 5, 6, 8, 10, 12, 16, and 20. Maybe the PLL doesn't like input frequencies this low?

* | ``QPLL0_SDM_CFG0``
  | Related to the sigma-delta modulator for fractional-N in QPLL0.

  * Bits 15:8: always 0
  * Bit 7: 0 if using fractional-N, 1 if not
  * Bits 6:0: always 0

* | ``QPLL0_SDM_CFG1``
  | Related to the sigma-delta modulator for fractional-N in QPLL0. Always ``16'b0000000000000000``

* | ``QPLL0_SDM_CFG2``
  | Related to the sigma-delta modulator for fractional-N in QPLL0. Always ``16'b0000000000000000``

* | ``QPLL1CLKOUT_RATE``
  | QPLL1 output divide-by-two control.

  * ``HALF``: Enable the output divider (output clock is half the VCO rate)
  * ``FULL``: Bypass the divider (output clock is equal to the VCO rate)

* | ``QPLL1_CFG0``
  | TODO

* | ``QPLL1_CFG1``
  | TODO

* | ``QPLL1_CFG1_G3``
  | TODO

* | ``QPLL1_CFG2``
  | TODO

* | ``QPLL1_CFG2_G3``
  | TODO

* | ``QPLL1_CFG3``
  | TODO

* | ``QPLL1_CFG4``
  | TODO

* | ``QPLL1_CP``
  | TODO

* | ``QPLL1_CP_G3``
  | TODO

* | ``QPLL1_FBDIV``
  | QPLL1 feedback divider N. Set to an integer between 16 and 160 to control the PLL multiplier between VCO and PFD.

* | ``QPLL1_FBDIV_G3``
  | Related to QPLL1 feedback divider but not yet understood

* | ``QPLL1_INIT_CFG0``
  | TODO

* | ``QPLL1_INIT_CFG1``
  | TODO

* | ``QPLL1_LOCK_CFG``
  | TODO

* | ``QPLL1_LOCK_CFG_G3``
  | TODO

* | ``QPLL1_LPF``
  | TODO

* | ``QPLL1_LPF_G3``
  | TODO

* | ``QPLL1_PCI_EN``
  | Always 1'b0 in all configurations tested to date, but we have not tested anything using the PCIe IP.

* | ``QPLL1_RATE_SW_USE_DRP``
  | TODO

* | ``QPLL1_REFCLK_DIV``
  | QPLL1 reference clock divider. Set to an integer between 1 and 4 to control the input divider between refclk input and PFD.
  | NOTE: according to UG578 table B-1, this attribute can also take the values 5, 6, 8, 10, 12, 16, and 20. Maybe the PLL doesn't like input frequencies this low?

* | ``QPLL1_SDM_CFG0``
  | TODO

* | ``QPLL1_SDM_CFG1``
  | TODO

* | ``QPLL1_SDM_CFG2``
  | TODO

* | ``RSVD_ATTR0``
  | Always ``16'b0000000000000000``

* | ``RSVD_ATTR1``
  | Always ``16'b0000000000000000``

* | ``RSVD_ATTR2``
  | Always ``16'b0000000000000000``

* | ``RSVD_ATTR3``
  | Always ``16'b0000000000000000``

* | ``RXRECCLKOUT0_SEL``
  | Controls RX recovered clock output, TODO

* | ``RXRECCLKOUT1_SEL``
  | Controls RX recovered clock output, TODO

* | ``SARC_ENB``
  | Always ``1'b0``

* | ``SARC_SEL``
  | Always ``1'b0``

* | ``SDM0INITSEED0_0``
  | Initial value for something in the sigma-delta modulator. Always ``16'b0000000100010001``

* | ``SDM0INITSEED0_1``
  | Initial value for something in the sigma-delta modulator. Always ``9'b000010001``

* | ``SDM1INITSEED0_0``
  | Initial value for something in the sigma-delta modulator. Always ``16'b0000000100010001``

* | ``SDM1INITSEED0_1``
  | Initial value for something in the sigma-delta modulator. Always ``9'b000010001``

* | ``SIM_DEVICE``
  | Selects the simulation model to use, ignored for synthesis. Should always be set to ``ULTRASCALE_PLUS``

* | ``SIM_MODE``
  | Selects something related to simulation, ignored for synthesis. Should always be set to ``FAST``

* | ``SIM_RESET_SPEEDUP``
  | Selects a tradeoff between simulation fidelity and speed. Valid values:

  * ``TRUE`` (default) simplified reset model, fastest simulation
  * ``FAST_ALIGN``: speed up simulation of TX/RX buffer bypass mode
  * ``FALSE``: most accurate modeling of reset behavior

* | ``UB_CFG0``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG1``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG2``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG3``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG4``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG5``
  | Always ``16'b0000010000000000``. Related to the hard MicroBlaze somehow.

* | ``UB_CFG6``
  | Always ``16'b0000000000000000``. Related to the hard MicroBlaze somehow.

Ports
------

* | ``BGBYPASSB``
  | Enable the internal bandgap voltage reference. Always ``1'b1``

* | ``BGMONITORENB``
  | Related to the internal bandgap voltage reference. Always ``1'b1``.

* | ``BGPDB``
  | Power up the internal bandgap voltage reference. Always ``1'b1``.

* | ``BGRCALOVRD``
  | Related to calibration of the internal bandgap voltage reference. Always ``5'b11111``.

* | ``BGRCALOVRDENB``
  | Related to calibration of the internal bandgap voltage reference. Always ``1'b1``.

* | ``DRPADDR``
  | DRP address bus. If bridging to APB, connect to ``PADDR``. Note that ``DRPADDR`` is word addressed, not byte addressed, so it may be necessary to truncate LSBs of ``PADDR``.

* | ``DRPCLK``
  | DRP clock. If bridging to APB, connect to ``PCLK``.

* | ``DRPDI``
  | DRP write data. If bridging to APB, connect to ``PWDATA``

* | ``DRPDO``
  | DRP read data. If bridging to APB, connect to ``PRDATA``

* | ``DRPEN``
  | DRP enable. If bridging to APB, connect to ``PENABLE``

* | ``DRPRDY``
  | DRP transaction complete. If bridging to APB, connect to ``PREADY``

* | ``DRPWE``
  | DRP write enable. If bridging to APB, connect to ``PWRITE``

* | ``GTGREFCLK0``
  | Connection point for internally generated factory test clock source. Always ``1'b0``

* | ``GTGREFCLK1``
  | Connection point for internally generated factory test clock source. Always ``1'b0``

* | ``GTNORTHREFCLK00``
  | Input reference clock 0 to QPLL0 coming from quad N-1 or N-2 - one or two quads to the **south** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the south quads.

* | ``GTNORTHREFCLK01``
  | Input reference clock 0 to QPLL1 coming from quad N-1 or N-2 - one or two quads to the **south** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the south quads.

* | ``GTNORTHREFCLK10``
  | Input reference clock 1 to QPLL0 coming from quad N-1 or N-2 - one or two quads to the **south** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the south quads.

* | ``GTNORTHREFCLK11``
  | Input reference clock 1 to QPLL1 coming from quad N-1 or N-2 - one or two quads to the **south** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the south quads.

* | ``GTREFCLK00``
  | Input reference clock 0 to QPLL0 coming the dedicated reference pins of the local quad.

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in the same quad the ``GTYE4_COMMON`` is located in.

* | ``GTREFCLK01``
  | Input reference clock 0 to QPLL1 coming the dedicated reference pins of the local quad.

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in the same quad the ``GTYE4_COMMON`` is located in.

* | ``GTREFCLK10``
  | Input reference clock 1 to QPLL0 coming the dedicated reference pins of the local quad.

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in the same quad the ``GTYE4_COMMON`` is located in.

* | ``GTREFCLK11``
  | Input reference clock 1 to QPLL1 coming the dedicated reference pins of the local quad.

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in the same quad the ``GTYE4_COMMON`` is located in.

* | ``GTSOUTHREFCLK00``
  | Input reference clock 0 to QPLL0 coming from quad N+1 or N+2 - one or two quads to the **north** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the north quads.

* | ``GTSOUTHREFCLK01``
  | Input reference clock 0 to QPLL1 coming from quad N+1 or N+2 - one or two quads to the **north** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the north quads.

* | ``GTSOUTHREFCLK10``
  | Input reference clock 1 to QPLL0 coming from quad N+1 or N+2 - one or two quads to the **north** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the north quads.

* | ``GTSOUTHREFCLK11``
  | Input reference clock 1 to QPLL1 coming from quad N+1 or N+2 - one or two quads to the **north** (yes, the naming is backwards).

  | Must be connected to either ``1'b0`` (if not used) or the output of an ``IBUFDS_GTE4`` cell in one of the north quads.

* | ``PCIERATEQPLL0``
  | Reserved, tie to ``1'b0``

* | ``PCIERATEQPLL1``
  | Reserved, tie to ``1'b0``

* | ``PMARSVD0``
  | Reserved, tie to ``8'b00000000``

* | ``PMARSVD1``
  | Reserved, tie to ``8'b00000000``

* | ``PMARSVDOUT0``
  | Reserved, leave floating

* | ``PMARSVDOUT1``
  | Reserved, leave floating

* | ``QPLL0CLKRSVD0``
  | Reserved, tie to ``1'b0``

* | ``QPLL0CLKRSVD1``
  | Reserved, tie to ``1'b0``

* | ``QPLL0FBCLKLOST``
  | Active-high output indicating loss of feedback clock to QPLL0 PFD

* | ``QPLL0FBDIV``
  | Reserved, tie to ``8'h0``

* | ``QPLL0LOCK``
  | Active high output indicating QPLL0 lock

* | ``QPLL0LOCKDETCLK``
  | Reference clock used to drive ``QPLL0FBCLKLOST`` and ``QPLL0REFCLKLOST`` clock detection logic. Must be generated from a separate source (not synchronous to the QPLL reference clock, or generated by the QPLL).

* | ``QPLL0LOCKEN``
  | Enable QPLL0 lock detection logic. Always tie to ``1'b1``

* | ``QPLL0OUTCLK``
  | Output clock from the QPLL, after the optional divide-by-two stage controlled by ``QPLL0CLKOUT_RATE``

* | ``QPLL0OUTREFCLK``
  | Forwarded copy of the QPLL reference clock, taken from the output of the ``QPLL0REFCLKSEL`` mux before the ``QPLL0_REFCLK_DIV`` divider. Connect to the ``QPLL0OUTREFCLK`` input of each instantiated ``GTYE4_CHANNEL`` primitive in the quad.

* | ``QPLL0PD``
  | Active-high power down signal, for disabling the QPLL when not used.

* | ``QPLL0REFCLKLOST``
  | Active-high output indicating loss of the reference clock to QPLL0.

* | ``QPLL0REFCLKSEL``
  | Reference clock input mux for QPLL0. The QPLL must be manually reset if this value is changed after configuration.

  * 0: Reserved, do not use
  * 1: ``GTREFCLK00`` input
  * 2: ``GTREFCLK10`` input
  * 3: ``GTNORTHREFCLK00`` input (from quad to the **south**)
  * 4: ``GTNORTHREFCLK10`` input (from quad to the **south**)
  * 5: ``GTSOUTHREFCLK00`` input (from quad to the **north**)
  * 6: ``GTSOUTHREFCLK10`` input (from quad to the **north**)
  * 7: Internally generated test clock, do not use

* | ``QPLL0RESET``
  | Active-high reset for QPLL0.

* | ``QPLL1CLKRSVD0``
  | Reserved, tie to ``1'b0``

* | ``QPLL1CLKRSVD1``
  | Reserved, tie to ``1'b0``

* | ``QPLL1FBCLKLOST``
  | Active-high output indicating loss of feedback clock to QPLL1 PFD

* | ``QPLL1FBDIV``
  | Reserved, tie to ``8'h0``

* | ``QPLL1LOCK``
  | Active high output indicating QPLL1 lock

* | ``QPLL1LOCKDETCLK``
  | Reference clock used to drive ``QPLL1FBCLKLOST`` and ``QPLL1REFCLKLOST`` clock detection logic. Must be generated from a separate source (not synchronous to the QPLL reference clock, or generated by the QPLL).

* | ``QPLL1LOCKEN``
  | Enable QPLL1 lock detection logic. Always tie to ``1'b1``

* | ``QPLL1OUTCLK``
  | Output clock from the QPLL, after the optional divide-by-two stage controlled by ``QPLL1CLKOUT_RATE``

* | ``QPLL1OUTREFCLK``
  | Forwarded copy of the QPLL reference clock, taken from the output of the ``QPLL1REFCLKSEL`` mux before the ``QPLL1_REFCLK_DIV`` divider. Connect to the ``QPLL1OUTREFCLK`` input of each instantiated ``GTYE4_CHANNEL`` primitive in the quad.

* | ``QPLL1PD``
  | Active-high power down signal, for disabling the QPLL when not used.

* | ``QPLL1REFCLKLOST``
  | Active-high output indicating loss of the reference clock to QPLL0.

* | ``QPLL1REFCLKSEL``
  | Reference clock input mux for QPLL1. The QPLL must be manually reset if this value is changed after configuration.

* | ``QPLL1RESET``
  | Active-high reset for QPLL1.

* | ``QPLLDMONITOR0``
  | Reserved, leave floating

* | ``QPLLDMONITOR1``
  | Reserved, leave floating

* | ``QPLLRSVD1``
  | Reserved, tie to ``8'b00000000``

* | ``QPLLRSVD2``
  | Reserved, tie to ``5'b00000``

* | ``QPLLRSVD3``
  | Reserved, tie to ``5'b00000``

* | ``QPLLRSVD4``
  | Reserved, tie to ``8'b00000000``

* | ``RCALENB``
  | Reserved, tie to ``1'b1``

* | ``REFCLKOUTMONITOR0``
  | QPLL0 reference clock mux monitor output. Not clear how this differs from ``QPLL0OUTREFCLK``. Maybe an internal test point that doesn't drive the clock tree? Most designs should float this as it's not needed.

* | ``REFCLKOUTMONITOR1``
  | QPLL1 reference clock mux monitor output. Not clear how this differs from ``QPLL1OUTREFCLK``. Maybe an internal test point that doesn't drive the clock tree? Most designs should float this as it's not needed.

* | ``RXRECCLK0SEL``
  | Mux selector for recovered clock output. Connect to ``RXRECCLK_SEL`` port of an ``OBUFDS_GTE4_ADV`` if outputting a recovered clock, or float if not required.

* | ``RXRECCLK1SEL``
  | Mux selector for recovered clock output. Connect to ``RXRECCLK_SEL`` port of an ``OBUFDS_GTE4_ADV`` if outputting a recovered clock, or float if not required.

* | ``SDM0DATA``
  | Fractional part of the fractional-N divider for QPLL0. Bits 23:0 are valid, bit 24 is a dontcare.

* | ``SDM0FINALOUT``
  | Reserved, leave floating

* | ``SDM0RESET``
  | Active-high reset for the QPLL0 fractional-N divider

* | ``SDM0TESTDATA``
  | Reserved, leave floating

* | ``SDM0TOGGLE``
  | Asynchronous strobe for loading the ``SDM0DATA`` value into the internal PLL sigma-delta modulator clock domain. The following timing constraints apply:

  * Setup time: 1 SYSTEM clock cycle from ``SDM0DATA`` valid to ``SDM0TOGGLE`` high
  * Pulse width: 3 PFD clock cycles of ``SDM0TOGGLE`` high
  * Hold time: 3 PFD clock cycles from ``SDM0TOGGLE`` low to ``SDM0DATA`` invalid

  | SYSTEM clock apparently refers to the clock domain driving ``SDM0DATA`` and ``SDM0TOGGLE`` which should be one of the ``USRCLK`` or ``DRPCLK`` domains?

* | ``SDM0WIDTH``
  | Width of the fractional-N divide value for QPLL0. Legal values are 16, 20, or 24. Should normally be tied to 24 to enable the greatest dynamic range possible for fractional-N.

* | ``SDM1DATA``
  | Fractional part of the fractional-N divider for QPLL1. Bits 23:0 are valid, bit 24 is a dontcare.

* | ``SDM1FINALOUT``
  | Reserved, leave floating

* | ``SDM1RESET``
  | Active-high reset for the QPLL1 fractional-N divider

* | ``SDM1TESTDATA``
  | Reserved, leave floating

* | ``SDM1TOGGLE``
  | Asynchronous strobe for loading the ``SDM1DATA`` value into the internal PLL sigma-delta modulator clock domain. The following timing constraints apply:

  * Setup time: 1 SYSTEM clock cycle from ``SDM1DATA`` valid to ``SDM1TOGGLE`` high
  * Pulse width: 3 PFD clock cycles of ``SDM1TOGGLE`` high
  * Hold time: 3 PFD clock cycles from ``SDM1TOGGLE`` low to ``SDM1DATA`` invalid

  | SYSTEM clock apparently refers to the clock domain driving ``SDM1DATA`` and ``SDM1TOGGLE`` which should be one of the ``USRCLK`` or ``DRPCLK`` domains?

* | ``SDM1WIDTH``
  | Width of the fractional-N divide value for QPLL1. Legal values are 16, 20, or 24. Should normally be tied to 24 to enable the greatest dynamic range possible for fractional-N.

* | ``UBCFGSTREAMEN``
  | Unknown, related to configuration. Tie to ``1'b0``

* | ``UBDADDR``
  | DRP output from hard MicroBlaze to access the DRP? Leave floating.

* | ``UBDEN``
  | DRP output from hard MicroBlaze to access the DRP? Leave floating.

* | ``UBDI``
  | DRP output from hard MicroBlaze to access the DRP? Leave floating.

* | ``UBDO``
  | DRP input from hard MicroBlaze to access the DRP? Tie to ``16'h0``

* | ``UBDRDY``
  | DRP input from hard MicroBlaze to access the DRP? Tie to ``1'h0``

* | ``UBDWE``
  | DRP output from hard MicroBlaze to access the DRP? Leave floating.

* | ``UBENABLE``
  | DRP output from hard MicroBlaze to access the DRP? Leave floating.

* | ``UBGPI``
  | Unknown input to hard MicroBlaze. Tie to ``2'b0``

* | ``UBINTR``
  | Interrupt input to hard MicroBlaze. Tie to ``2'b0``

* | ``UBIOLMBRST``
  | Unknown reset input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMBRST``
  | Unknown reset input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMDMCAPTURE``
  | Unknown input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMDMDBGRST``
  | Unknown reset input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMDMDBGUPDATE``
  | Unknown input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMDMREGEN``
  | Unknown input to hard MicroBlaze. Tie to ``4'h0``

* | ``UBMDMSHIFT``
  | Unknown input to hard MicroBlaze. Tie to ``1'b0``

* | ``UBMDMSYSRST``
  | Reset input for hard MicroBlaze? Tie to ``1'b0``.

* | ``UBMDMTCK``
  | JTAG TCK pin from hard MicroBlaze. Tie to ``1'b0``.
  | TODO: poke at this

* | ``UBMDMTDI``
  | JTAG TDI pin from hard MicroBlaze. Tie to ``1'b0``.
  | TODO: poke at this

* | ``UBMDMTDO``
  | JTAG TDO pin from hard MicroBlaze. Leave floating.
  | TODO: poke at this

* | ``UBRSVDOUT``
  | Output from hard MicroBlaze. Leave floating.
  | TODO: poke at this

* | ``UBTXUART``
  | UART output from the hard MicroBlaze. Most designs should float this.
  | TODO: actually see if there's any output on this during normal operation

``GTYE4_CHANNEL``
=================

Attributes
-----------
* | ``ACJTAG_DEBUG_MODE``
  | Factory test interface. Always ``1'b0``

* | ``ACJTAG_MODE``
  | Factory test interface. Always ``1'b0``

* | ``ACJTAG_RESET``
  | Factory test interface. Always ``1'b0``

* | ``ADAPT_CFG0``

* | ``ADAPT_CFG1``

* | ``ADAPT_CFG2``

* | ``ALIGN_COMMA_DOUBLE``

  * ``TRUE``: search for a 20-bit wide double 8b/10b comma character, consisting of a comma+ followed by a comma-
  * ``FALSE`` normal operation (align to a single comma)

* | ``ALIGN_COMMA_ENABLE``

  * ``TRUE``: enable the 8b/10b RX comma aligner
  * ``FALSE``: disable the comma aligner.

* | ``ALIGN_COMMA_WORD``
  | Controls which byte lane positions a comma can be aligned to.

  * 1: comma may occur in any byte lane
  * 2: comma may occur in byte lane 0 or (if 32/40 bit internal datapath) lane 2
  * 4: comma may only occur in byte lane 0 (only valid if 32/40 bit internal datapath).

  | Note that the comma aligner works on the internal datapath (max 4 byte width), not the external (max 8 byte). This means that when operating the external datapath in half-rate mode compared to the internal (e.g. 4 byte internal, 8 byte external) the comma may align to either the low or high half of the output word (e.g. byte lanes 0 or 4 if ``ALIGN_COMMA_WORD`` is 4)

* | ``ALIGN_MCOMMA_DET``

  * ``TRUE``: Comma aligner searches for comma-
  * ``FALSE``: Ignore negative commas

* | ``ALIGN_PCOMMA_DET``

  * ``TRUE``: Comma aligner searches for comma+
  * ``FALSE``: Ignore positive commas

* | ``CBCC_DATA_SOURCE_SEL``

* | ``CDR_SWAP_MODE_EN``
  | Something undocumented in the clock recovery block. Always ``1'b0``.

* | ``CFOK_PWRSVE_EN``
  | Enables power save mode for something, maybe? Always ``1'b1``.

* | ``CHAN_BOND_KEEP_ALIGN``

  * ``TRUE``: Preserve channel bond alignment when a multilane link is idle
  * ``FALSE``: Realign when the link wakes up.

  If not using channel bonding, set to ``FALSE``.

* | ``CHAN_BOND_MAX_SKEW``
  | Maximum skew between lanes, in symbols, that the elastic buffer can correct for. Must be between 1 and 14.
  | Optimal value is floor(D/2) where D is the number of symbols between channel bonding sequences. Smaller values require increasingly tight tolerances on PCB trace skew, while values above D/2 risk the deskew block locking to an incorrect alignment.

  | If not using channel bonding, set to 1.
* | ``CHAN_BOND_SEQ_1_1``
  | First 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 1. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_1_2``
  | Second 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 1. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_1_3``
  | Third 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 1. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_1_4``
  | Fourth 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 1. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_1_ENABLE``
  | Bitmask for channel bonding sequence 1 allowing some symbols within the sequence to be ignored (always match). For each bit, 0 = ignore, 1 = pattern match. Set to ``4'b1111`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_1``
  | First 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 2. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_2``
  | Second 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 2. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_3``
  | Third 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 2. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_4``
  | Fourth 8 or 10 bit (depending on ``RX_DATA_WIDTH`` / ``CBCC_DATA_SOURCE_SEL``) symbol in channel bonding sequence 2. Value is protocol dependent; set to ``10'b0000000000`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_ENABLE``
  | Bitmask for channel bonding sequence 2 allowing some symbols within the sequence to be ignored (always match). For each bit, 0 = ignore, 1 = pattern match. Set to ``4'b1111`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_2_USE``

  * ``TRUE``: Channel bonding will search for either sequence 1 or 2
  * ``FALSE``: Channel bonding only searches for sequence 1 (sequence 2 values dontcare)

  Set to ``FALSE`` if not using channel bonding.

* | ``CHAN_BOND_SEQ_LEN``
  | Number of symbols in the channel bonding sequence (starting from symbol 1). Must be 1, 2, or 4. Set to 1 if not using channel bonding.

* | ``CH_HSPMUX``
  | Some kind of internal multiplexer setting. Appears to be two one-hot 2:1 muxes with the remaining bits set zero at this time, but not fully understood yet. More RE needed. Value depends on data rate. EDIT: this is wrong, some new configs have 4 bits set

* | ``CKCAL1_CFG_0``
* | ``CKCAL1_CFG_1``
* | ``CKCAL1_CFG_2``
* | ``CKCAL1_CFG_3``
* | ``CKCAL2_CFG_0``
* | ``CKCAL2_CFG_1``
* | ``CKCAL2_CFG_2``
* | ``CKCAL2_CFG_3``
* | ``CKCAL2_CFG_4``
* | ``CLK_CORRECT_USE``
* | ``CLK_COR_KEEP_IDLE``
* | ``CLK_COR_MAX_LAT``
* | ``CLK_COR_MIN_LAT``
* | ``CLK_COR_PRECEDENCE``
* | ``CLK_COR_REPEAT_WAIT``
* | ``CLK_COR_SEQ_1_1``
* | ``CLK_COR_SEQ_1_2``
* | ``CLK_COR_SEQ_1_3``
* | ``CLK_COR_SEQ_1_4``
* | ``CLK_COR_SEQ_1_ENABLE``
* | ``CLK_COR_SEQ_2_1``
* | ``CLK_COR_SEQ_2_2``
* | ``CLK_COR_SEQ_2_3``
* | ``CLK_COR_SEQ_2_4``
* | ``CLK_COR_SEQ_2_ENABLE``
* | ``CLK_COR_SEQ_2_USE``
* | ``CLK_COR_SEQ_LEN``
* | ``CPLL_CFG0``
  | Channel PLL configuration TODO

* | ``CPLL_CFG1``
  | Channel PLL configuration TODO

* | ``CPLL_CFG2``
  | Channel PLL configuration TODO

* | ``CPLL_CFG3``
  | Channel PLL configuration TODO

* | ``CPLL_FBDIV``
  | Channel PLL configuration TODO

* | ``CPLL_FBDIV_45``
  | Channel PLL configuration TODO

* | ``CPLL_INIT_CFG0``
  | Channel PLL configuration TODO

* | ``CPLL_LOCK_CFG``
  | Channel PLL configuration TODO

* | ``CPLL_REFCLK_DIV``
  | Channel PLL configuration TODO

* | ``CTLE3_OCAP_EXT_CTRL``
* | ``CTLE3_OCAP_EXT_EN``
* | ``DDI_CTRL``
* | ``DDI_REALIGN_WAIT``
* | ``DEC_MCOMMA_DETECT``
* | ``DEC_PCOMMA_DETECT``
* | ``DELAY_ELEC``
* | ``DMONITOR_CFG0``
* | ``DMONITOR_CFG1``

* | ``ES_CLK_PHASE_SEL``
  | Controls something unknown in the eye scan block. Set to ``1'b0``.

* | ``ES_CONTROL``
  | Command register for the eye scan logic. Should be set to ``6'b000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_ERRDET_EN``
  | Switches the SDATA bus between equivalent-time sampling and error-detect modes. Set to ``FALSE`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_EYE_SCAN_EN``

  * ``TRUE``: enable eye scan logic
  * ``FALSE``: power down eye scan logic for a slight power savings if not used

* | ``ES_HORZ_OFFSET``
  | X position of current eye scan sample. Set to ``12'b000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_PRESCALE``
  | Prescaler (2^{1+ES_PRESCALE}) for sample/error count. Must be 0 to 31; set to ``5'b00000`` if not using eye scan

* | ``ES_QUALIFIER0``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER1``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER2``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER3``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER4``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER5``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER6``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER7``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER8``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUALIFIER9``
  | Pattern match value for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK0``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK1``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK2``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK3``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK4``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK5``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK6``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK7``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK8``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_QUAL_MASK9``
  | Pattern mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK0``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK1``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK2``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK3``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK4``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK5``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK6``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK7``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK8``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``ES_SDATA_MASK9``
  | Data mask for eye scan qualified BER measurements. Set to ``16'b0000000000000000`` on the primitive, then update as needed via DRP if doing eye scans.

* | ``EYESCAN_VP_RANGE``
  | Related to eye scan, but doesn't seem to be used for anything? Always set to 0

* | ``EYE_SCAN_SWAP_EN``
  | Related to eye scan, exact functionality unclear. Always set to ``1'b0``.

* | ``FTS_DESKEW_SEQ_ENABLE``
* | ``FTS_LANE_DESKEW_CFG``
* | ``FTS_LANE_DESKEW_EN``
* | ``GEARBOX_MODE``
* | ``ISCAN_CK_PH_SEL2``
* | ``LOCAL_MASTER``
* | ``LPBK_BIAS_CTRL``
* | ``LPBK_EN_RCAL_B``
* | ``LPBK_EXT_RCAL``
* | ``LPBK_IND_CTRL0``
* | ``LPBK_IND_CTRL1``
* | ``LPBK_IND_CTRL2``
* | ``LPBK_RG_CTRL``
* | ``OOBDIVCTL``
* | ``OOB_PWRUP``
* | ``PCI3_AUTO_REALIGN``
* | ``PCI3_PIPE_RX_ELECIDLE``
* | ``PCI3_RX_ASYNC_EBUF_BYPASS``
* | ``PCI3_RX_ELECIDLE_EI2_ENABLE``
* | ``PCI3_RX_ELECIDLE_H2L_COUNT``
* | ``PCI3_RX_ELECIDLE_H2L_DISABLE``
* | ``PCI3_RX_ELECIDLE_HI_COUNT``
* | ``PCI3_RX_ELECIDLE_LP4_DISABLE``
* | ``PCI3_RX_FIFO_DISABLE``
* | ``PCIE3_CLK_COR_EMPTY_THRSH``
* | ``PCIE3_CLK_COR_FULL_THRSH``
* | ``PCIE3_CLK_COR_MAX_LAT``
* | ``PCIE3_CLK_COR_MIN_LAT``
* | ``PCIE3_CLK_COR_THRSH_TIMER``
* | ``PCIE_64B_DYN_CLKSW_DIS``
* | ``PCIE_BUFG_DIV_CTRL``
* | ``PCIE_GEN4_64BIT_INT_EN``
* | ``PCIE_PLL_SEL_MODE_GEN12``
* | ``PCIE_PLL_SEL_MODE_GEN3``
* | ``PCIE_PLL_SEL_MODE_GEN4``
* | ``PCIE_RXPCS_CFG_GEN3``
* | ``PCIE_RXPMA_CFG``
* | ``PCIE_TXPCS_CFG_GEN3``
* | ``PCIE_TXPMA_CFG``
* | ``PCS_PCIE_EN``
* | ``PCS_RSVD0``
* | ``PD_TRANS_TIME_FROM_P2``
* | ``PD_TRANS_TIME_NONE_P2``
* | ``PD_TRANS_TIME_TO_P2``
* | ``PREIQ_FREQ_BST``
  | Controls some kind of data rate dependent high frequency boost. Exact functionality not well understood.
  | Values range from 0 or 1 at lower data rates (roughly 10 Gbps and below) to 2 around 20 Gbps and 3 around 25 Gbps, but RE is still ongoing.
  | In particular, around 10 Gbps the transfer function from data rate to PREIQ_FREQ_BST appears non-monotonic.
* | ``RATE_SW_USE_DRP``
* | ``RCLK_SIPO_DLY_ENB``
* | ``RCLK_SIPO_INV_EN``
* | ``RTX_BUF_CML_CTRL``
* | ``RTX_BUF_TERM_CTRL``
* | ``RXBUFRESET_TIME``
* | ``RXBUF_ADDR_MODE``
* | ``RXBUF_EIDLE_HI_CNT``
* | ``RXBUF_EIDLE_LO_CNT``
* | ``RXBUF_EN``
* | ``RXBUF_RESET_ON_CB_CHANGE``
* | ``RXBUF_RESET_ON_COMMAALIGN``
* | ``RXBUF_RESET_ON_EIDLE``
* | ``RXBUF_RESET_ON_RATE_CHANGE``
* | ``RXBUF_THRESH_OVFLW``
* | ``RXBUF_THRESH_OVRD``
* | ``RXBUF_THRESH_UNDFLW``
* | ``RXCDRFREQRESET_TIME``
* | ``RXCDRPHRESET_TIME``
* | ``RXCDR_CFG0``
* | ``RXCDR_CFG0_GEN3``
* | ``RXCDR_CFG1``
* | ``RXCDR_CFG1_GEN3``
* | ``RXCDR_CFG2``
* | ``RXCDR_CFG2_GEN2``
* | ``RXCDR_CFG2_GEN3``
* | ``RXCDR_CFG2_GEN4``
* | ``RXCDR_CFG3``
* | ``RXCDR_CFG3_GEN2``
* | ``RXCDR_CFG3_GEN3``
* | ``RXCDR_CFG3_GEN4``
* | ``RXCDR_CFG4``
* | ``RXCDR_CFG4_GEN3``
* | ``RXCDR_CFG5``
* | ``RXCDR_CFG5_GEN3``
* | ``RXCDR_FR_RESET_ON_EIDLE``
* | ``RXCDR_HOLD_DURING_EIDLE``
* | ``RXCDR_LOCK_CFG0``
* | ``RXCDR_LOCK_CFG1``
* | ``RXCDR_LOCK_CFG2``
* | ``RXCDR_LOCK_CFG3``
* | ``RXCDR_LOCK_CFG4``
* | ``RXCDR_PH_RESET_ON_EIDLE``
* | ``RXCFOK_CFG0``
* | ``RXCFOK_CFG1``
* | ``RXCFOK_CFG2``
* | ``RXCKCAL1_IQ_LOOP_RST_CFG``
* | ``RXCKCAL1_I_LOOP_RST_CFG``
* | ``RXCKCAL1_Q_LOOP_RST_CFG``
* | ``RXCKCAL2_DX_LOOP_RST_CFG``
* | ``RXCKCAL2_D_LOOP_RST_CFG``
* | ``RXCKCAL2_S_LOOP_RST_CFG``
* | ``RXCKCAL2_X_LOOP_RST_CFG``
* | ``RXDFELPMRESET_TIME``
* | ``RXDFELPM_KL_CFG0``
* | ``RXDFELPM_KL_CFG1``
* | ``RXDFELPM_KL_CFG2``
* | ``RXDFE_CFG0``
* | ``RXDFE_CFG1``
* | ``RXDFE_GC_CFG0``
* | ``RXDFE_GC_CFG1``
* | ``RXDFE_GC_CFG2``
* | ``RXDFE_H2_CFG0``
* | ``RXDFE_H2_CFG1``
* | ``RXDFE_H3_CFG0``
* | ``RXDFE_H3_CFG1``
* | ``RXDFE_H4_CFG0``
* | ``RXDFE_H4_CFG1``
* | ``RXDFE_H5_CFG0``
* | ``RXDFE_H5_CFG1``
* | ``RXDFE_H6_CFG0``
* | ``RXDFE_H6_CFG1``
* | ``RXDFE_H7_CFG0``
* | ``RXDFE_H7_CFG1``
* | ``RXDFE_H8_CFG0``
* | ``RXDFE_H8_CFG1``
* | ``RXDFE_H9_CFG0``
* | ``RXDFE_H9_CFG1``
* | ``RXDFE_HA_CFG0``
* | ``RXDFE_HA_CFG1``
* | ``RXDFE_HB_CFG0``
* | ``RXDFE_HB_CFG1``
* | ``RXDFE_HC_CFG0``
* | ``RXDFE_HC_CFG1``
* | ``RXDFE_HD_CFG0``
* | ``RXDFE_HD_CFG1``
* | ``RXDFE_HE_CFG0``
* | ``RXDFE_HE_CFG1``
* | ``RXDFE_HF_CFG0``
* | ``RXDFE_HF_CFG1``
* | ``RXDFE_KH_CFG0``
* | ``RXDFE_KH_CFG1``
* | ``RXDFE_KH_CFG2``
* | ``RXDFE_KH_CFG3``

* | ``RXDFE_OS_CFG0``

* | ``RXDFE_OS_CFG1``

* | ``RXDFE_UT_CFG0``

* | ``RXDFE_UT_CFG1``

* | ``RXDFE_UT_CFG2``

* | ``RXDFE_VP_CFG0``

* | ``RXDFE_VP_CFG1``

* | ``RXDLY_CFG``

* | ``RXDLY_LCFG``

* | ``RXELECIDLE_CFG``

* | ``RXGBOX_FIFO_INIT_RD_ADDR``

* | ``RXGEARBOX_EN``

* | ``RXISCANRESET_TIME``

* | ``RXLPM_CFG``

* | ``RXLPM_GC_CFG``

* | ``RXLPM_KH_CFG0``

* | ``RXLPM_KH_CFG1``

* | ``RXLPM_OS_CFG0``

* | ``RXLPM_OS_CFG1``

* | ``RXOOB_CFG``

* | ``RXOOB_CLK_CFG``

* | ``RXOSCALRESET_TIME``

* | ``RXOUT_DIV``

* | ``RXPCSRESET_TIME``

* | ``RXPHBEACON_CFG``

* | ``RXPHDLY_CFG``

* | ``RXPHSAMP_CFG``

* | ``RXPHSLIP_CFG``

* | ``RXPH_MONITOR_SEL``

* | ``RXPI_CFG0``

* | ``RXPI_CFG1``

* | ``RXPMACLK_SEL``

* | ``RXPMARESET_TIME``

* | ``RXPRBS_ERR_LOOPBACK``

* | ``RXPRBS_LINKACQ_CNT``

* | ``RXREFCLKDIV2_SEL``

* | ``RXSLIDE_AUTO_WAIT``

* | ``RXSLIDE_MODE``

* | ``RXSYNC_MULTILANE``

* | ``RXSYNC_OVRD``

* | ``RXSYNC_SKIP_DA``

* | ``RX_AFE_CM_EN``

* | ``RX_BIAS_CFG0``

* | ``RX_BUFFER_CFG``

* | ``RX_CAPFF_SARC_ENB``

* | ``RX_CLK25_DIV``
  | Divider from reference clock to get a nominally 25 MHz internal clock for the RX logic.
  | The divider must be between 1 and 32, and the resulting clock frequency must not exceed 25 MHz.
  | For example, use a divide value of 4 for a 100 MHz reference clock, but 5 for 100.01 MHz.

* | ``RX_CLKMUX_EN``

* | ``RX_CLK_SLIP_OVRD``

* | ``RX_CM_BUF_CFG``

* | ``RX_CM_BUF_PD``

* | ``RX_CM_SEL``

* | ``RX_CM_TRIM``

* | ``RX_CTLE_PWR_SAVING``

* | ``RX_CTLE_RES_CTRL``

* | ``RX_DATA_WIDTH``

* | ``RX_DDI_SEL``

* | ``RX_DEFER_RESET_BUF_EN``

* | ``RX_DEGEN_CTRL``

* | ``RX_DFELPM_CFG0``

* | ``RX_DFELPM_CFG1``

* | ``RX_DFELPM_KLKH_AGC_STUP_EN``

* | ``RX_DFE_AGC_CFG1``

* | ``RX_DFE_KL_LPM_KH_CFG0``

* | ``RX_DFE_KL_LPM_KH_CFG1``

* | ``RX_DFE_KL_LPM_KL_CFG0``

* | ``RX_DFE_KL_LPM_KL_CFG1``

* | ``RX_DFE_LPM_HOLD_DURING_EIDLE``

* | ``RX_DISPERR_SEQ_MATCH``

* | ``RX_DIVRESET_TIME``

* | ``RX_EN_CTLE_RCAL_B``

* | ``RX_EN_SUM_RCAL_B``

* | ``RX_EYESCAN_VS_CODE``

* | ``RX_EYESCAN_VS_NEG_DIR``

* | ``RX_EYESCAN_VS_RANGE``

* | ``RX_EYESCAN_VS_UT_SIGN``

* | ``RX_FABINT_USRCLK_FLOP``

* | ``RX_I2V_FILTER_EN``

* | ``RX_INT_DATAWIDTH``

* | ``RX_PMA_POWER_SAVE``

* | ``RX_PMA_RSV0``

* | ``RX_PROGDIV_CFG``

* | ``RX_PROGDIV_RATE``

* | ``RX_RESLOAD_CTRL``

* | ``RX_RESLOAD_OVRD``

* | ``RX_SAMPLE_PERIOD``

* | ``RX_SUM_DEGEN_AVTT_OVERITE``

* | ``RX_SUM_DFETAPREP_EN``

* | ``RX_SUM_IREF_TUNE``

* | ``RX_SUM_PWR_SAVING``

* | ``RX_SUM_RES_CTRL``

* | ``RX_SUM_VCMTUNE``

* | ``RX_SUM_VCM_BIAS_TUNE_EN``

* | ``RX_SUM_VCM_OVWR``

* | ``RX_SUM_VREF_TUNE``

* | ``RX_TUNE_AFE_OS``

* | ``RX_VREG_CTRL``

* | ``RX_VREG_PDB``

* | ``RX_WIDEMODE_CDR``
  | Data rate dependent adjustment of something in the RX clock recovery block.

  * 15 Gbps and below: 2'b01
  * 20 Gbps and above: 2'b10

  | RE is ongoing, the exact transition points are not currently known.

* | ``RX_WIDEMODE_CDR_GEN3``
  | Always 2'b00

* | ``RX_WIDEMODE_CDR_GEN4``
  | Always 2'b01

* | ``RX_XCLK_SEL``

* | ``RX_XMODE_SEL``
  | Data rate dependent adjustment of something in the receiver.

  * 10.3125 Gbps and below: 1'b1
  * 15 Gbps and above: 1'b0

* | ``SAMPLE_CLK_PHASE``

* | ``SAS_12G_MODE``

* | ``SATA_BURST_SEQ_LEN``

* | ``SATA_CPLL_CFG``

* | ``SHOW_REALIGN_COMMA``

* | ``SIM_DEVICE``

* | ``SIM_MODE``

* | ``SIM_RECEIVER_DETECT_PASS``

* | ``SIM_RESET_SPEEDUP``

* | ``SIM_TX_EIDLE_DRIVE_LEVEL``

* | ``SRSTMODE``

* | ``TAPDLY_SET_TX``

* | ``TERM_RCAL_CFG``

* | ``TERM_RCAL_OVRD``

* | ``TRANS_TIME_RATE``

* | ``TST_RSV0``

* | ``TST_RSV1``

* | ``TXBUF_EN``

* | ``TXBUF_RESET_ON_RATE_CHANGE``

* | ``TXDLY_CFG``

* | ``TXDLY_LCFG``

* | ``TXDRV_FREQBAND``
  | Specifies the frequency range the output driver is operating in.

  * 10.3125 Gbps and below: 0
  * 15-20 Gbps: 1
  * 25 Gbps: 3

  | RE is ongoing, the exact transition points are not currently known.

* | ``TXFE_CFG0``

* | ``TXFE_CFG1``

* | ``TXFE_CFG2``

* | ``TXFE_CFG3``

* | ``TXFIFO_ADDR_CFG``

* | ``TXGBOX_FIFO_INIT_RD_ADDR``

* | ``TXGEARBOX_EN``

* | ``TXOUT_DIV``

* | ``TXPCSRESET_TIME``

* | ``TXPHDLY_CFG0``

* | ``TXPHDLY_CFG1``

* | ``TXPH_CFG``

* | ``TXPH_CFG2``

* | ``TXPH_MONITOR_SEL``

* | ``TXPI_CFG0``

* | ``TXPI_CFG1``

* | ``TXPI_GRAY_SEL``

* | ``TXPI_INVSTROBE_SEL``

* | ``TXPI_PPM``

* | ``TXPI_PPM_CFG``

* | ``TXPI_SYNFREQ_PPM``

* | ``TXPMARESET_TIME``

* | ``TXREFCLKDIV2_SEL``

* | ``TXSWBST_BST``

* | ``TXSWBST_EN``

* | ``TXSWBST_MAG``

* | ``TXSYNC_MULTILANE``

* | ``TXSYNC_OVRD``

* | ``TXSYNC_SKIP_DA``

* | ``TX_CLK25_DIV``
  | Divider from reference clock to get a nominally 25 MHz internal clock for the TX logic.
  | The divider must be between 1 and 32, and the resulting clock frequency must not exceed 25 MHz.
  | For example, use a divide value of 4 for a 100 MHz reference clock, but 5 for 100.01 MHz.

* | ``TX_CLKMUX_EN``

* | ``TX_DATA_WIDTH``

* | ``TX_DCC_LOOP_RST_CFG``

* | ``TX_DEEMPH0``

* | ``TX_DEEMPH1``

* | ``TX_DEEMPH2``

* | ``TX_DEEMPH3``

* | ``TX_DIVRESET_TIME``

* | ``TX_DRIVE_MODE``

* | ``TX_EIDLE_ASSERT_DELAY``

* | ``TX_EIDLE_DEASSERT_DELAY``

* | ``TX_FABINT_USRCLK_FLOP``

* | ``TX_FIFO_BYP_EN``

* | ``TX_IDLE_DATA_ZERO``

* | ``TX_INT_DATAWIDTH``

* | ``TX_LOOPBACK_DRIVE_HIZ``

* | ``TX_MAINCURSOR_SEL``

* | ``TX_MARGIN_FULL_0``

* | ``TX_MARGIN_FULL_1``

* | ``TX_MARGIN_FULL_2``

* | ``TX_MARGIN_FULL_3``

* | ``TX_MARGIN_FULL_4``

* | ``TX_MARGIN_LOW_0``

* | ``TX_MARGIN_LOW_1``

* | ``TX_MARGIN_LOW_2``

* | ``TX_MARGIN_LOW_3``

* | ``TX_MARGIN_LOW_4``

* | ``TX_PHICAL_CFG0``

* | ``TX_PHICAL_CFG1``

* | ``TX_PI_BIASSET``

* | ``TX_PMADATA_OPT``

* | ``TX_PMA_POWER_SAVE``

* | ``TX_PMA_RSV0``

* | ``TX_PMA_RSV1``

* | ``TX_PROGCLK_SEL``

* | ``TX_PROGDIV_CFG``

* | ``TX_PROGDIV_RATE``

* | ``TX_RXDETECT_CFG``

* | ``TX_RXDETECT_REF``

* | ``TX_SAMPLE_PERIOD``

* | ``TX_SW_MEAS``

* | ``TX_VREG_CTRL``
  | Controls an internal voltage regulator in the transmit logic, maybe a trim setting? Always 3'b011

* | ``TX_VREG_PDB``
  | Enables power to an internal voltage regulator in the transmit logic. Always 1'b1

* | ``TX_VREG_VREFSEL``

* | ``TX_XCLK_SEL``

* | ``USB_BOTH_BURST_IDLE``

* | ``USB_BURSTMAX_U3WAKE``

* | ``USB_BURSTMIN_U3WAKE``

* | ``USB_CLK_COR_EQ_EN``

* | ``USB_EXT_CNTL``

* | ``USB_IDLEMAX_POLLING``

* | ``USB_IDLEMIN_POLLING``

* | ``USB_LFPSPING_BURST``

* | ``USB_LFPSPOLLING_BURST``

* | ``USB_LFPSPOLLING_IDLE_MS``

* | ``USB_LFPSU1EXIT_BURST``

* | ``USB_LFPSU2LPEXIT_BURST_MS``

* | ``USB_LFPSU3WAKE_BURST_MS``

* | ``USB_LFPS_TPERIOD``

* | ``USB_LFPS_TPERIOD_ACCURATE``

* | ``USB_MODE``

* | ``USB_PCIE_ERR_REP_DIS``

* | ``USB_PING_SATA_MAX_INIT``

* | ``USB_PING_SATA_MIN_INIT``

* | ``USB_POLL_SATA_MAX_BURST``

* | ``USB_POLL_SATA_MIN_BURST``

* | ``USB_RAW_ELEC``

* | ``USB_RXIDLE_P0_CTRL``

* | ``USB_TXIDLE_TUNE_ENABLE``

* | ``USB_U1_SATA_MAX_WAKE``

* | ``USB_U1_SATA_MIN_WAKE``

* | ``USB_U2_SAS_MAX_COM``

* | ``USB_U2_SAS_MIN_COM``

* | ``USE_PCS_CLK_PHASE_SEL``
  | Always 1'b0.

* | ``Y_ALL_MODE``
  | Always 1'b0.

Ports
-----------

