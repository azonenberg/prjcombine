GTY Transceiver
############

Introduction
===============

GTY transceivers are organized in quads. Each quad contains one ``GTYE4_COMMON`` and four ``GTYE4_CHANNEL``. The primitives are very minimally documented; for most parameters the only mention in the datasheet is "use the magic value from the wizard". This page aims to provide some more fundamental understanding of the actual attributes, sufficient to enable using the raw primitives without the wizard.

GTYs can operate at a maximum data rate of 32.75 Gbps (package and speed grade dependent).

Information in this page is derived from careful reading of DS922, analysis of configurations generated by the Vivado 2019.2 transceivers wizard, and testing on live hardware.

Clocking
-----------

TX and RX of each channel can be clocked independently from one of three sources:

* QPLL0 (in COMMON block, shared by all CHANNELs in the quad)
* QPLL1 (in COMMON block, shared by all CHANNELs in the quad)
* CPLL (in CHANNEL block, dedicated to this CHANNEL)

Each PLL has a different operating frequency range, which must be carefully considered when planning complex setups with multiple lanes in a quad running at different data rates.

In the case of KU+, the native data rates for each PLL at the nominal Vcore are as follows. To run at lower rates than shown here, the QPLL output divider and/or channel sub-rate modes must be used.

* CPLL: 4.0 to:
	* -1 speed: 8.5 Gbps
	* -2 or -3 speed: 12.5 Gbps
* QPLL0: 19.6 to:
    * -1 speed: 25.785 Gbps
    * -2 speed: 28.21 Gbps
    * -3 speed: 32.75 Gbps
* QPLL1: 16.0 to:
    * -1 speed: 25.785 Gbps
    * -2 or -3 speed: 26.0 Gbps

Check table 64 of DS922 for full details on voltage ranges and data rates.

Note that the internal transceiver drive circuitry is DDR, i.e. for 20 Gbps data rate the PLL VCO should be running at 10 GHz.

``GTYE4_COMMON``
==============

Attributes
-----------

* | **BIAS_CFG0**
  | Always 16'b0000000000000000
* | **BIAS_CFG1**
  | Always 16'b0000000000000000
* | **BIAS_CFG2**
  | Always 16'b0000010100100100
* | **BIAS_CFG3**
  | Always 16'b0000000001000001
* | **BIAS_CFG4**
  | Always 16'b0000000000010000
* | **BIAS_CFG_RSVD**
  | Always 16'b0000000000000000
* | **COMMON_CFG0**
  | Always 16'b0000000000000000
* | **COMMON_CFG1**
  | Always 16'b0000000000000000
* | **POR_CFG**
  | Always 16'b0000000000000000
* | **PPF0_CFG**
  | Something to do with QPLL0. Not yet fully understood. So far:
  * Bits 15:13: always 0
  * Bit 12: 1 if using fractional-N, 0 if not
  * Bit 11: 0 if using fractional-N, 1 if not
  * Bit 10: both 0 and 1 seen, but no clear pattern yet
  * Bits 9:0: always 0
* | **PPF1_CFG**
  | Seems to be same mapping as PPF0_CFG but for QPLL1
* | **QPLL0CLKOUT_RATE**
  | QPLL0 output divide-by-two control. Set to "HALF" to enable the divider or "FULL" to bypass it.
* | **QPLL0_CFG0**
  | Always 16'b0011001100011100
* | **QPLL0_CFG1**
  | Always 16'b1101000000111000
* | **QPLL0_CFG1_G3**
  | Always 16'b1101000000111000
* | **QPLL0_CFG2**
  | Something to do with QPLL0. Not yet fully understood. So far:
  * Bits 15:12: always 0
  * Bits 11:6: always 1
  * Bits 5:2: always 0
  * Bits 1:0: both 1 if using fractional-N, 0 if not
* | **QPLL0_CFG2_G3**
  | Always same as QPLL0_CFG2
* | **QPLL0_CFG3**
  | Always 16'b0000000100100000
* | **QPLL0_CFG4**
  | Something to do with QPLL0. Not yet fully understood. So far:
  * Bits 15:8: always 0
  * Bit 7: 1 if using fractional-N, 0 if not
  * Bits 6:3: always 0
  * Bit 2: 1 if using fractional-N, 0 if not
  * Bit 1: 0 if using fractional-N, 1 if not
  * Bit 0: both 0 and 1 seen, but no clear pattern yet
* | **QPLL0_CP**
  | Always 10'b0011111111
* | **QPLL0_CP_G3**
  | Always 10'b0000001111
* | **QPLL0_FBDIV**
  | QPLL0 feedback divider N. Set to an integer between 16 and 160 to control the PLL multiplier between VCO and PFD.
* | **QPLL0_FBDIV_G3**
  | Related to QPLL0 feedback divider but not yet understood. Values seen so far 160 and 128. Possible values in DRP range 16 to 160.
* | **QPLL0_INIT_CFG0**
  | Always 16'b0000001010110010
* | **QPLL0_INIT_CFG1**
  | Always 8'b00000000
* | **QPLL0_LOCK_CFG**
  | Always 16'b0010010111101000
* | **QPLL0_LOCK_CFG_G3**
  | Always 16'b0010010111101000
* | **QPLL0_LPF**
  | Probably controls something in the QPLL0 loop filter
  * Bit 9: always 1
  * Bits 8:6: always 0
  * Bit 5: 0 if using fractional-N, 1 if not
  * Bits 4:0: always 1
* | **QPLL0_LPF_G3**
  | Always 10'b0111010101
* | **QPLL0_PCI_EN**
  | Always 1'b0 in all configurations tested to date, but we have not tested anything using the PCIe IP.
* | **QPLL0_RATE_SW_USE_DRP**
  | Always 1'b1
* | **QPLL0_REFCLK_DIV**
  | QPLL0 reference clock divider. Set to an integer between 1 and 4 to control the input divider between refclk input and PFD.
  | NOTE: according to UG578 table B-1, this attribute can also take the values 5, 6, 8, 10, 12, 16, and 20. Maybe the PLL doesn't like input frequencies this low?
* | **QPLL0_SDM_CFG0**
  * Bits 15:8: always 0
  * Bit 7: 0 if using fractional-N, 1 if not
  * Bits 6:0: always 0
* | **QPLL0_SDM_CFG1**
  | So far, always 16'b0000000000000000
* | **QPLL0_SDM_CFG2**
  | So far, always 16'b0000000000000000
* | **QPLL1CLKOUT_RATE**
  | QPLL1 output divide-by-two control. Set to "HALF" to enable the divider or "FULL" to bypass it.
* | **QPLL1_CFG0**
  | TODO
* | **QPLL1_CFG1**
  | TODO
* | **QPLL1_CFG1_G3**
  | TODO
* | **QPLL1_CFG2**
  | TODO
* | **QPLL1_CFG2_G3**
  | TODO
* | **QPLL1_CFG3**
  | TODO
* | **QPLL1_CFG4**
  | Need to work on this more
  * Bits 16:2: always 0
  * Bit 1: always 1
  * Bit 0: 0 for half rate mode, 1 for full rate mode (TODO verify with more configs)
* | **QPLL1_CP**
  | TODO
* | **QPLL1_CP_G3**
  | TODO
* | **QPLL1_FBDIV**
  | QPLL1 feedback divider N. Set to an integer between 16 and 160 to control the PLL multiplier between VCO and PFD.
* | **QPLL1_FBDIV_G3**
  | Related to QPLL1 feedback divider but not yet understood
* | **QPLL1_INIT_CFG0**
  | TODO
* | **QPLL1_INIT_CFG1**
  | TODO
* | **QPLL1_LOCK_CFG**
  | TODO
* | **QPLL1_LOCK_CFG_G3**
  | TODO
* | **QPLL1_LPF**
  | TODO
* | **QPLL1_LPF_G3**
  | TODO
* | **QPLL1_PCI_EN**
  | Always 1'b0 in all configurations tested to date, but we have not tested anything using the PCIe IP.
* | **QPLL1_RATE_SW_USE_DRP**
  | TODO
* | **QPLL1_REFCLK_DIV**
  | QPLL1 reference clock divider. Set to an integer between 1 and 4 to control the input divider between refclk input and PFD.
  | NOTE: according to UG578 table B-1, this attribute can also take the values 5, 6, 8, 10, 12, 16, and 20. Maybe the PLL doesn't like input frequencies this low?
* | **QPLL1_SDM_CFG0**
  | TODO
* | **QPLL1_SDM_CFG1**
  | TODO
* | **QPLL1_SDM_CFG2**
  | TODO
* | **RSVD_ATTR0**
  | Always 16'b0000000000000000
* | **RSVD_ATTR1**
  | Always 16'b0000000000000000
* | **RSVD_ATTR2**
  | Always 16'b0000000000000000
* | **RSVD_ATTR3**
  | Always 16'b0000000000000000
* | **RXRECCLKOUT0_SEL**
  | Controls RX recovered clock output, TODO
* | **RXRECCLKOUT1_SEL**
  | Controls RX recovered clock output, TODO
* | **SARC_ENB**
  | Always 1'b0
* | **SARC_SEL**
  | Always 1'b0
* | **SDM0INITSEED0_0**
  | Always 16'b0000000100010001
* | **SDM0INITSEED0_1**
  | Always 9'b000010001
* | **SDM1INITSEED0_0**
  | Always 16'b0000000100010001
* | **SDM1INITSEED0_1**
  | Always 9'b000010001
* | **SIM_DEVICE**
  | Selects the simulation model to use, ignored for synthesis. Should always be set to "ULTRASCALE_PLUS"
* | **SIM_MODE**
  | Selects something related to simulation, ignored for synthesis. Should always be set to "FAST"
* | **SIM_RESET_SPEEDUP**
  | Selects a tradeoff between simulation fidelity and speed. Valid values:
  * "TRUE" (default) simplified reset model, fastest simulation
  * "FAST_ALIGN": speed up simulation of TX/RX buffer bypass mode
  * "FALSE": most accurate modeling of reset behavior
* | **UB_CFG0**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG1**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG2**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG3**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG4**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG5**
  | Always 16'b0000010000000000. Related to the hard MicroBlaze somehow.
* | **UB_CFG6**
  | Always 16'b0000000000000000. Related to the hard MicroBlaze somehow.

Ports
-----------

``GTYE4_CHANNEL``
===============

Attributes
-----------
* | **ACJTAG_DEBUG_MODE**
  | Factory test interface. Always 1'b0
* | **ACJTAG_MODE**
  | Factory test interface. Always 1'b0
* | **ACJTAG_RESET**
  | Factory test interface. Always 1'b0
* | **ADAPT_CFG0**
* | **ADAPT_CFG1**
* | **ADAPT_CFG2**
* | **ALIGN_COMMA_DOUBLE**
  | Set "TRUE" to search for a 20-bit wide double 8b/10b comma character, consisting of a comma+ followed by a comma-. Set "FALSE" for normal operation (align to a single comma).
* | **ALIGN_COMMA_ENABLE**
  | Set "TRUE" to enable the 8b/10b RX comma aligner, "FALSE" to disable.
* | **ALIGN_COMMA_WORD**
  | Controls which byte lane positions a comma can be aligned to.
  * 1: comma may occur in any byte lane
  * 2: comma may occur in byte lane 0 or (if 32/40 bit internal datapath) lane 2
  * 4: comma may only occur in byte lane 0 (only valid if 32/40 bit internal datapath).
  | Note that the comma aligner works on the internal datapath (max 4 byte width), not the external (max 8 byte). This means that when operating the external datapath in half-rate mode compared to the internal (e.g. 4 byte internal, 8 byte external) the comma may align to either the low or high half of the output word (e.g. byte lanes 0 or 4 if ALIGN_COMMA_WORD is 4)
* | **ALIGN_MCOMMA_DET**
  | Set "TRUE" for the comma aligner to search for comma-. Set "FALSE" to ignore negative commas.
* | **ALIGN_PCOMMA_DET**
  | Set "TRUE" for the comma aligner to search for comma+. Set "FALSE" to ignore positive commas.
* | **CBCC_DATA_SOURCE_SEL**
* | **CDR_SWAP_MODE_EN**
  | Something undocumented in the clock recovery block. Always 1'b0.
* | **CFOK_PWRSVE_EN**
  | Enables low power mode for something, maybe? Always 1'b1.
* | **CHAN_BOND_KEEP_ALIGN**
  | Set "TRUE" to preserve channel bond alignment when a multilane link is idle. Set "FALSE" to realign when the link wakes up, or if not using channel bonding.
* | **CHAN_BOND_MAX_SKEW**
  | Maximum skew between lanes, in symbols, that the elastic buffer can correct for. Must be between 1 and 14.
  | Optimal value is floor(D/2) where D is the number of symbols between channel bonding sequences. Smaller values require increasingly tight tolerances on PCB trace skew, while values above D/2 risk the deskew block locking to an incorrect alignment.
  | If not using channel bonding, set to 1.
* | **CHAN_BOND_SEQ_1_1**
  | First 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 1. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_1_2**
  | Second 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 1. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_1_3**
  | Third 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 1. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_1_4**
  | Fourth 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 1. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_1_ENABLE**
  | Bitmask for channel bonding sequence 1 allowing some symbols within the sequence to be ignored (always match). For each bit, 0 = ignore, 1 = pattern match. Set to 4'b1111 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_1**
  | First 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 2. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_2**
  | Second 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 2. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_3**
  | Third 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 2. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_4**
  | Fourth 8 or 10 bit (depending on RX_DATA_WIDTH / CBCC_DATA_SOURCE_SEL) symbol in channel bonding sequence 2. Value is protocol dependent; set to 10'b0000000000 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_ENABLE**
  | Bitmask for channel bonding sequence 2 allowing some symbols within the sequence to be ignored (always match). For each bit, 0 = ignore, 1 = pattern match. Set to 4'b1111 if not using channel bonding.
* | **CHAN_BOND_SEQ_2_USE**
  | Set "TRUE" for channel bonding to match either sequence 1 or 2. Set "FALSE" to only match sequence 1 (sequence 2 values dontcare), or if not using channel bonding.
* | **CHAN_BOND_SEQ_LEN**
  | Number of symbols in the channel bonding sequence (starting from symbol 1). Must be 1, 2, or 4. Set to 1 if not using channel bonding.
* | **CH_HSPMUX**
  | Some kind of internal multiplexer setting. Appears to be two one-hot 2:1 muxes with the remaining bits set zero at this time, but not fully understood yet. More RE needed. Value depends on data rate.
* | **CKCAL1_CFG_0**
* | **CKCAL1_CFG_1**
* | **CKCAL1_CFG_2**
* | **CKCAL1_CFG_3**
* | **CKCAL2_CFG_0**
* | **CKCAL2_CFG_1**
* | **CKCAL2_CFG_2**
* | **CKCAL2_CFG_3**
* | **CKCAL2_CFG_4**
* | **CLK_CORRECT_USE**
* | **CLK_COR_KEEP_IDLE**
* | **CLK_COR_MAX_LAT**
* | **CLK_COR_MIN_LAT**
* | **CLK_COR_PRECEDENCE**
* | **CLK_COR_REPEAT_WAIT**
* | **CLK_COR_SEQ_1_1**
* | **CLK_COR_SEQ_1_2**
* | **CLK_COR_SEQ_1_3**
* | **CLK_COR_SEQ_1_4**
* | **CLK_COR_SEQ_1_ENABLE**
* | **CLK_COR_SEQ_2_1**
* | **CLK_COR_SEQ_2_2**
* | **CLK_COR_SEQ_2_3**
* | **CLK_COR_SEQ_2_4**
* | **CLK_COR_SEQ_2_ENABLE**
* | **CLK_COR_SEQ_2_USE**
* | **CLK_COR_SEQ_LEN**
* | **CPLL_CFG0**
* | **CPLL_CFG1**
* | **CPLL_CFG2**
* | **CPLL_CFG3**
* | **CPLL_FBDIV**
* | **CPLL_FBDIV_45**
* | **CPLL_INIT_CFG0**
* | **CPLL_LOCK_CFG**
* | **CPLL_REFCLK_DIV**
* | **CTLE3_OCAP_EXT_CTRL**
* | **CTLE3_OCAP_EXT_EN**
* | **DDI_CTRL**
* | **DDI_REALIGN_WAIT**
* | **DEC_MCOMMA_DETECT**
* | **DEC_PCOMMA_DETECT**
* | **DELAY_ELEC**
* | **DMONITOR_CFG0**
* | **DMONITOR_CFG1**
* | **ES_CLK_PHASE_SEL**
* | **ES_CONTROL**
* | **ES_ERRDET_EN**
* | **ES_EYE_SCAN_EN**
* | **ES_HORZ_OFFSET**
* | **ES_PRESCALE**
* | **ES_QUALIFIER0**
* | **ES_QUALIFIER1**
* | **ES_QUALIFIER2**
* | **ES_QUALIFIER3**
* | **ES_QUALIFIER4**
* | **ES_QUALIFIER5**
* | **ES_QUALIFIER6**
* | **ES_QUALIFIER7**
* | **ES_QUALIFIER8**
* | **ES_QUALIFIER9**
* | **ES_QUAL_MASK0**
* | **ES_QUAL_MASK1**
* | **ES_QUAL_MASK2**
* | **ES_QUAL_MASK3**
* | **ES_QUAL_MASK4**
* | **ES_QUAL_MASK5**
* | **ES_QUAL_MASK6**
* | **ES_QUAL_MASK7**
* | **ES_QUAL_MASK8**
* | **ES_QUAL_MASK9**
* | **ES_SDATA_MASK0**
* | **ES_SDATA_MASK1**
* | **ES_SDATA_MASK2**
* | **ES_SDATA_MASK3**
* | **ES_SDATA_MASK4**
* | **ES_SDATA_MASK5**
* | **ES_SDATA_MASK6**
* | **ES_SDATA_MASK7**
* | **ES_SDATA_MASK8**
* | **ES_SDATA_MASK9**
* | **EYESCAN_VP_RANGE**
* | **EYE_SCAN_SWAP_EN**
* | **FTS_DESKEW_SEQ_ENABLE**
* | **FTS_LANE_DESKEW_CFG**
* | **FTS_LANE_DESKEW_EN**
* | **GEARBOX_MODE**
* | **ISCAN_CK_PH_SEL2**
* | **LOCAL_MASTER**
* | **LPBK_BIAS_CTRL**
* | **LPBK_EN_RCAL_B**
* | **LPBK_EXT_RCAL**
* | **LPBK_IND_CTRL0**
* | **LPBK_IND_CTRL1**
* | **LPBK_IND_CTRL2**
* | **LPBK_RG_CTRL**
* | **OOBDIVCTL**
* | **OOB_PWRUP**
* | **PCI3_AUTO_REALIGN**
* | **PCI3_PIPE_RX_ELECIDLE**
* | **PCI3_RX_ASYNC_EBUF_BYPASS**
* | **PCI3_RX_ELECIDLE_EI2_ENABLE**
* | **PCI3_RX_ELECIDLE_H2L_COUNT**
* | **PCI3_RX_ELECIDLE_H2L_DISABLE**
* | **PCI3_RX_ELECIDLE_HI_COUNT**
* | **PCI3_RX_ELECIDLE_LP4_DISABLE**
* | **PCI3_RX_FIFO_DISABLE**
* | **PCIE3_CLK_COR_EMPTY_THRSH**
* | **PCIE3_CLK_COR_FULL_THRSH**
* | **PCIE3_CLK_COR_MAX_LAT**
* | **PCIE3_CLK_COR_MIN_LAT**
* | **PCIE3_CLK_COR_THRSH_TIMER**
* | **PCIE_64B_DYN_CLKSW_DIS**
* | **PCIE_BUFG_DIV_CTRL**
* | **PCIE_GEN4_64BIT_INT_EN**
* | **PCIE_PLL_SEL_MODE_GEN12**
* | **PCIE_PLL_SEL_MODE_GEN3**
* | **PCIE_PLL_SEL_MODE_GEN4**
* | **PCIE_RXPCS_CFG_GEN3**
* | **PCIE_RXPMA_CFG**
* | **PCIE_TXPCS_CFG_GEN3**
* | **PCIE_TXPMA_CFG**
* | **PCS_PCIE_EN**
* | **PCS_RSVD0**
* | **PD_TRANS_TIME_FROM_P2**
* | **PD_TRANS_TIME_NONE_P2**
* | **PD_TRANS_TIME_TO_P2**
* | **PREIQ_FREQ_BST**
  | Controls some kind of data rate dependent high frequency boost. Exact functionality not well understood.
  | Values range from 0 or 1 at lower data rates (roughly 10 Gbps and below) to 2 around 20 Gbps and 3 around 25 Gbps, but RE is still ongoing.
  | In particular, around 10 Gbps the transfer function from data rate to PREIQ_FREQ_BST appears non-monotonic.
* | **RATE_SW_USE_DRP**
* | **RCLK_SIPO_DLY_ENB**
* | **RCLK_SIPO_INV_EN**
* | **RTX_BUF_CML_CTRL**
* | **RTX_BUF_TERM_CTRL**
* | **RXBUFRESET_TIME**
* | **RXBUF_ADDR_MODE**
* | **RXBUF_EIDLE_HI_CNT**
* | **RXBUF_EIDLE_LO_CNT**
* | **RXBUF_EN**
* | **RXBUF_RESET_ON_CB_CHANGE**
* | **RXBUF_RESET_ON_COMMAALIGN**
* | **RXBUF_RESET_ON_EIDLE**
* | **RXBUF_RESET_ON_RATE_CHANGE**
* | **RXBUF_THRESH_OVFLW**
* | **RXBUF_THRESH_OVRD**
* | **RXBUF_THRESH_UNDFLW**
* | **RXCDRFREQRESET_TIME**
* | **RXCDRPHRESET_TIME**
* | **RXCDR_CFG0**
* | **RXCDR_CFG0_GEN3**
* | **RXCDR_CFG1**
* | **RXCDR_CFG1_GEN3**
* | **RXCDR_CFG2**
* | **RXCDR_CFG2_GEN2**
* | **RXCDR_CFG2_GEN3**
* | **RXCDR_CFG2_GEN4**
* | **RXCDR_CFG3**
* | **RXCDR_CFG3_GEN2**
* | **RXCDR_CFG3_GEN3**
* | **RXCDR_CFG3_GEN4**
* | **RXCDR_CFG4**
* | **RXCDR_CFG4_GEN3**
* | **RXCDR_CFG5**
* | **RXCDR_CFG5_GEN3**
* | **RXCDR_FR_RESET_ON_EIDLE**
* | **RXCDR_HOLD_DURING_EIDLE**
* | **RXCDR_LOCK_CFG0**
* | **RXCDR_LOCK_CFG1**
* | **RXCDR_LOCK_CFG2**
* | **RXCDR_LOCK_CFG3**
* | **RXCDR_LOCK_CFG4**
* | **RXCDR_PH_RESET_ON_EIDLE**
* | **RXCFOK_CFG0**
* | **RXCFOK_CFG1**
* | **RXCFOK_CFG2**
* | **RXCKCAL1_IQ_LOOP_RST_CFG**
* | **RXCKCAL1_I_LOOP_RST_CFG**
* | **RXCKCAL1_Q_LOOP_RST_CFG**
* | **RXCKCAL2_DX_LOOP_RST_CFG**
* | **RXCKCAL2_D_LOOP_RST_CFG**
* | **RXCKCAL2_S_LOOP_RST_CFG**
* | **RXCKCAL2_X_LOOP_RST_CFG**
* | **RXDFELPMRESET_TIME**
* | **RXDFELPM_KL_CFG0**
* | **RXDFELPM_KL_CFG1**
* | **RXDFELPM_KL_CFG2**
* | **RXDFE_CFG0**
* | **RXDFE_CFG1**
* | **RXDFE_GC_CFG0**
* | **RXDFE_GC_CFG1**
* | **RXDFE_GC_CFG2**
* | **RXDFE_H2_CFG0**
* | **RXDFE_H2_CFG1**
* | **RXDFE_H3_CFG0**
* | **RXDFE_H3_CFG1**
* | **RXDFE_H4_CFG0**
* | **RXDFE_H4_CFG1**
* | **RXDFE_H5_CFG0**
* | **RXDFE_H5_CFG1**
* | **RXDFE_H6_CFG0**
* | **RXDFE_H6_CFG1**
* | **RXDFE_H7_CFG0**
* | **RXDFE_H7_CFG1**
* | **RXDFE_H8_CFG0**
* | **RXDFE_H8_CFG1**
* | **RXDFE_H9_CFG0**
* | **RXDFE_H9_CFG1**
* | **RXDFE_HA_CFG0**
* | **RXDFE_HA_CFG1**
* | **RXDFE_HB_CFG0**
* | **RXDFE_HB_CFG1**
* | **RXDFE_HC_CFG0**
* | **RXDFE_HC_CFG1**
* | **RXDFE_HD_CFG0**
* | **RXDFE_HD_CFG1**
* | **RXDFE_HE_CFG0**
* | **RXDFE_HE_CFG1**
* | **RXDFE_HF_CFG0**
* | **RXDFE_HF_CFG1**
* | **RXDFE_KH_CFG0**
* | **RXDFE_KH_CFG1**
* | **RXDFE_KH_CFG2**
* | **RXDFE_KH_CFG3**
* | **RXDFE_OS_CFG0**
* | **RXDFE_OS_CFG1**
* | **RXDFE_UT_CFG0**
* | **RXDFE_UT_CFG1**
* | **RXDFE_UT_CFG2**
* | **RXDFE_VP_CFG0**
* | **RXDFE_VP_CFG1**
* | **RXDLY_CFG**
* | **RXDLY_LCFG**
* | **RXELECIDLE_CFG**
* | **RXGBOX_FIFO_INIT_RD_ADDR**
* | **RXGEARBOX_EN**
* | **RXISCANRESET_TIME**
* | **RXLPM_CFG**
* | **RXLPM_GC_CFG**
* | **RXLPM_KH_CFG0**
* | **RXLPM_KH_CFG1**
* | **RXLPM_OS_CFG0**
* | **RXLPM_OS_CFG1**
* | **RXOOB_CFG**
* | **RXOOB_CLK_CFG**
* | **RXOSCALRESET_TIME**
* | **RXOUT_DIV**
* | **RXPCSRESET_TIME**
* | **RXPHBEACON_CFG**
* | **RXPHDLY_CFG**
* | **RXPHSAMP_CFG**
* | **RXPHSLIP_CFG**
* | **RXPH_MONITOR_SEL**
* | **RXPI_CFG0**
* | **RXPI_CFG1**
* | **RXPMACLK_SEL**
* | **RXPMARESET_TIME**
* | **RXPRBS_ERR_LOOPBACK**
* | **RXPRBS_LINKACQ_CNT**
* | **RXREFCLKDIV2_SEL**
* | **RXSLIDE_AUTO_WAIT**
* | **RXSLIDE_MODE**
* | **RXSYNC_MULTILANE**
* | **RXSYNC_OVRD**
* | **RXSYNC_SKIP_DA**
* | **RX_AFE_CM_EN**
* | **RX_BIAS_CFG0**
* | **RX_BUFFER_CFG**
* | **RX_CAPFF_SARC_ENB**
* | **RX_CLK25_DIV**
  | Divider from reference clock to get a nominally 25 MHz internal clock for the RX logic.
  | The divider must be between 1 and 32, and the resulting clock frequency must not exceed 25 MHz.
  | For example, use a divide value of 4 for a 100 MHz reference clock, but 5 for 100.01 MHz.
* | **RX_CLKMUX_EN**
* | **RX_CLK_SLIP_OVRD**
* | **RX_CM_BUF_CFG**
* | **RX_CM_BUF_PD**
* | **RX_CM_SEL**
* | **RX_CM_TRIM**
* | **RX_CTLE_PWR_SAVING**
* | **RX_CTLE_RES_CTRL**
* | **RX_DATA_WIDTH**
* | **RX_DDI_SEL**
* | **RX_DEFER_RESET_BUF_EN**
* | **RX_DEGEN_CTRL**
* | **RX_DFELPM_CFG0**
* | **RX_DFELPM_CFG1**
* | **RX_DFELPM_KLKH_AGC_STUP_EN**
* | **RX_DFE_AGC_CFG1**
* | **RX_DFE_KL_LPM_KH_CFG0**
* | **RX_DFE_KL_LPM_KH_CFG1**
* | **RX_DFE_KL_LPM_KL_CFG0**
* | **RX_DFE_KL_LPM_KL_CFG1**
* | **RX_DFE_LPM_HOLD_DURING_EIDLE**
* | **RX_DISPERR_SEQ_MATCH**
* | **RX_DIVRESET_TIME**
* | **RX_EN_CTLE_RCAL_B**
* | **RX_EN_SUM_RCAL_B**
* | **RX_EYESCAN_VS_CODE**
* | **RX_EYESCAN_VS_NEG_DIR**
* | **RX_EYESCAN_VS_RANGE**
* | **RX_EYESCAN_VS_UT_SIGN**
* | **RX_FABINT_USRCLK_FLOP**
* | **RX_I2V_FILTER_EN**
* | **RX_INT_DATAWIDTH**
* | **RX_PMA_POWER_SAVE**
* | **RX_PMA_RSV0**
* | **RX_PROGDIV_CFG**
* | **RX_PROGDIV_RATE**
* | **RX_RESLOAD_CTRL**
* | **RX_RESLOAD_OVRD**
* | **RX_SAMPLE_PERIOD**
* | **RX_SUM_DEGEN_AVTT_OVERITE**
* | **RX_SUM_DFETAPREP_EN**
* | **RX_SUM_IREF_TUNE**
* | **RX_SUM_PWR_SAVING**
* | **RX_SUM_RES_CTRL**
* | **RX_SUM_VCMTUNE**
* | **RX_SUM_VCM_BIAS_TUNE_EN**
* | **RX_SUM_VCM_OVWR**
* | **RX_SUM_VREF_TUNE**
* | **RX_TUNE_AFE_OS**
* | **RX_VREG_CTRL**
* | **RX_VREG_PDB**
* | **RX_WIDEMODE_CDR**
* | **RX_WIDEMODE_CDR_GEN3**
* | **RX_WIDEMODE_CDR_GEN4**
* | **RX_XCLK_SEL**
* | **RX_XMODE_SEL**
* | **SAMPLE_CLK_PHASE**
* | **SAS_12G_MODE**
* | **SATA_BURST_SEQ_LEN**
* | **SATA_CPLL_CFG**
* | **SHOW_REALIGN_COMMA**
* | **SIM_DEVICE**
* | **SIM_MODE**
* | **SIM_RECEIVER_DETECT_PASS**
* | **SIM_RESET_SPEEDUP**
* | **SIM_TX_EIDLE_DRIVE_LEVEL**
* | **SRSTMODE**
* | **TAPDLY_SET_TX**
* | **TERM_RCAL_CFG**
* | **TERM_RCAL_OVRD**
* | **TRANS_TIME_RATE**
* | **TST_RSV0**
* | **TST_RSV1**
* | **TXBUF_EN**
* | **TXBUF_RESET_ON_RATE_CHANGE**
* | **TXDLY_CFG**
* | **TXDLY_LCFG**
* | **TXDRV_FREQBAND**
* | **TXFE_CFG0**
* | **TXFE_CFG1**
* | **TXFE_CFG2**
* | **TXFE_CFG3**
* | **TXFIFO_ADDR_CFG**
* | **TXGBOX_FIFO_INIT_RD_ADDR**
* | **TXGEARBOX_EN**
* | **TXOUT_DIV**
* | **TXPCSRESET_TIME**
* | **TXPHDLY_CFG0**
* | **TXPHDLY_CFG1**
* | **TXPH_CFG**
* | **TXPH_CFG2**
* | **TXPH_MONITOR_SEL**
* | **TXPI_CFG0**
* | **TXPI_CFG1**
* | **TXPI_GRAY_SEL**
* | **TXPI_INVSTROBE_SEL**
* | **TXPI_PPM**
* | **TXPI_PPM_CFG**
* | **TXPI_SYNFREQ_PPM**
* | **TXPMARESET_TIME**
* | **TXREFCLKDIV2_SEL**
* | **TXSWBST_BST**
* | **TXSWBST_EN**
* | **TXSWBST_MAG**
* | **TXSYNC_MULTILANE**
* | **TXSYNC_OVRD**
* | **TXSYNC_SKIP_DA**
* | **TX_CLK25_DIV**
* | **TX_CLKMUX_EN**
* | **TX_DATA_WIDTH**
* | **TX_DCC_LOOP_RST_CFG**
* | **TX_DEEMPH0**
* | **TX_DEEMPH1**
* | **TX_DEEMPH2**
* | **TX_DEEMPH3**
* | **TX_DIVRESET_TIME**
* | **TX_DRIVE_MODE**
* | **TX_EIDLE_ASSERT_DELAY**
* | **TX_EIDLE_DEASSERT_DELAY**
* | **TX_FABINT_USRCLK_FLOP**
* | **TX_FIFO_BYP_EN**
* | **TX_IDLE_DATA_ZERO**
* | **TX_INT_DATAWIDTH**
* | **TX_LOOPBACK_DRIVE_HIZ**
* | **TX_MAINCURSOR_SEL**
* | **TX_MARGIN_FULL_0**
* | **TX_MARGIN_FULL_1**
* | **TX_MARGIN_FULL_2**
* | **TX_MARGIN_FULL_3**
* | **TX_MARGIN_FULL_4**
* | **TX_MARGIN_LOW_0**
* | **TX_MARGIN_LOW_1**
* | **TX_MARGIN_LOW_2**
* | **TX_MARGIN_LOW_3**
* | **TX_MARGIN_LOW_4**
* | **TX_PHICAL_CFG0**
* | **TX_PHICAL_CFG1**
* | **TX_PI_BIASSET**
* | **TX_PMADATA_OPT**
* | **TX_PMA_POWER_SAVE**
* | **TX_PMA_RSV0**
* | **TX_PMA_RSV1**
* | **TX_PROGCLK_SEL**
* | **TX_PROGDIV_CFG**
* | **TX_PROGDIV_RATE**
* | **TX_RXDETECT_CFG**
* | **TX_RXDETECT_REF**
* | **TX_SAMPLE_PERIOD**
* | **TX_SW_MEAS**
* | **TX_VREG_CTRL**
* | **TX_VREG_PDB**
* | **TX_VREG_VREFSEL**
* | **TX_XCLK_SEL**
* | **USB_BOTH_BURST_IDLE**
* | **USB_BURSTMAX_U3WAKE**
* | **USB_BURSTMIN_U3WAKE**
* | **USB_CLK_COR_EQ_EN**
* | **USB_EXT_CNTL**
* | **USB_IDLEMAX_POLLING**
* | **USB_IDLEMIN_POLLING**
* | **USB_LFPSPING_BURST**
* | **USB_LFPSPOLLING_BURST**
* | **USB_LFPSPOLLING_IDLE_MS**
* | **USB_LFPSU1EXIT_BURST**
* | **USB_LFPSU2LPEXIT_BURST_MS**
* | **USB_LFPSU3WAKE_BURST_MS**
* | **USB_LFPS_TPERIOD**
* | **USB_LFPS_TPERIOD_ACCURATE**
* | **USB_MODE**
* | **USB_PCIE_ERR_REP_DIS**
* | **USB_PING_SATA_MAX_INIT**
* | **USB_PING_SATA_MIN_INIT**
* | **USB_POLL_SATA_MAX_BURST**
* | **USB_POLL_SATA_MIN_BURST**
* | **USB_RAW_ELEC**
* | **USB_RXIDLE_P0_CTRL**
* | **USB_TXIDLE_TUNE_ENABLE**
* | **USB_U1_SATA_MAX_WAKE**
* | **USB_U1_SATA_MIN_WAKE**
* | **USB_U2_SAS_MAX_COM**
* | **USB_U2_SAS_MIN_COM**
* | **USE_PCS_CLK_PHASE_SEL**
* | **Y_ALL_MODE**

Ports
-----------

